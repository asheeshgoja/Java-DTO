//Auto generated code
//Code generated by XXsd2Code<http://xxsd2code.sourceforge.net/> XXsd2Code.exe version 1.0.0
//For any comments/suggestions contact code generator author at asheesh.goja@gmail.com
//Auto generated code
//Auto generated code
 
 
 
#pragma once
 
 
 
 
#include <string>
#include <vector>
#include <functional>
#include <algorithm>
using namespace std;
#include <tchar.h>
typedef basic_string<TCHAR> tstring;
 
 
#include "CommonSchemaElements.h"
 
 
using namespace CustomerOrderAndFulfillment::CommonSchemaElements;
 
 
namespace CustomerOrderAndFulfillment
{
	namespace Contract
	{
 
		//enumeration	CreditRating
		enum	CreditRating
		{
			Good = 700,
			VeryGood = 750,
			ExtremelyGood = 790,
			Poor = 300
			
		};
 
		//enumeration	FuzzyCondition
		enum	FuzzyCondition
		{
			Hot = 100,
			VeryHot = 200,
			ExtremelyHot = 300,
			Cold = 0
			
		};
 
		class	FulfillmentRecord
		{
		public:
			tstring			FulfillmentRecordID;
			bool			IsBackOrder;
			FuzzyCondition			StorageTemperature;
			tstring			CustomerOrderNo;
			
			//default constructor
			FulfillmentRecord()
			{
				IsBackOrder = false ;
				StorageTemperature = CustomerOrderAndFulfillment::Contract::Hot ;
			}
			
			//Destructor
			~FulfillmentRecord()
			{
			}
			
			//copy constuctor
			FulfillmentRecord(const  FulfillmentRecord& rhs){*this = rhs;}
			
			//= operator
			FulfillmentRecord& operator = (const FulfillmentRecord& rhs)
			{
				FulfillmentRecordID = rhs.FulfillmentRecordID ;
				IsBackOrder = rhs.IsBackOrder ;
				StorageTemperature = rhs.StorageTemperature ;
				CustomerOrderNo = rhs.CustomerOrderNo ;
				return *this;
			}
			
			};
 
			class	CustomerOrder
			{
			public:
				tstring				OrderNumber;
				CreditRating				Rating;
				CustomerOrderAndFulfillment::CommonSchemaElements::Address				AddressInfo;

				//Explicit Template Instantiation  Takes care of Warning C4251
				template class  std::allocator<CustomerOrderAndFulfillment::CommonSchemaElements::OrderItem*>;
				template class  std::vector<CustomerOrderAndFulfillment::CommonSchemaElements::OrderItem*, std::allocator<CustomerOrderAndFulfillment::CommonSchemaElements::OrderItem*> >;
				//End Explicit Template Instantiation 

				typedef vector<CustomerOrderAndFulfillment::CommonSchemaElements::OrderItem*>		OrderItem_VECTOR;
				OrderItem_VECTOR				Orders;
				CustomerOrderAndFulfillment::CommonSchemaElements::CreditCardDetails				CcInfo;
			
				//default constructor
				CustomerOrder()
				{
					Rating = CustomerOrderAndFulfillment::Contract::Good ;
				}
			
				//Destructor
				~CustomerOrder()
				{
					for_each(Orders.begin(),Orders.end(),&CustomerOrder::DeleteElement<OrderItem_VECTOR::value_type>);
					Orders.clear();
				}
			
				//copy constuctor
				CustomerOrder(const  CustomerOrder& rhs){*this = rhs;}
			
				//= operator
				CustomerOrder& operator = (const CustomerOrder& rhs)
				{
					OrderNumber = rhs.OrderNumber ;
					Rating = rhs.Rating ;
					AddressInfo = rhs.AddressInfo ;
					CopyVector<CustomerOrderAndFulfillment::CommonSchemaElements::OrderItem>(Orders,rhs.Orders) ;
					CcInfo = rhs.CcInfo ;
					return *this;
				}
			
			
				//Collection helpers
				private:
					template<typename TYPE>
					static void DeleteElement(TYPE element){delete element;}
			
					template<typename T , typename VECTOR>
					void CopyVector(VECTOR& dst, const  VECTOR& src )
					{
						for_each(dst.begin(),dst.end(),&CustomerOrder::DeleteElement<VECTOR::value_type>);
						dst.clear();
						for(size_t i = 0 ; i < src.size() ; i++)	dst.push_back( new T( *(src[i]) ) ) ;
					}
			
				};
			}
		}


